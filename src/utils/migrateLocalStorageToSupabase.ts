import { getString, setString, StorageKeys } from '@/lib/storage';
import { batchCreateBrandDeals, BrandDeal } from '@/services/brandDealsService';
import { updateUserStrategy, batchCreateGoals, GoalType, GoalStatus } from '@/services/strategyService';
import { batchCreatePlannerItems, PlannerItem } from '@/services/plannerService';
import { batchCreateProductionCards, ProductionCard } from '@/services/productionService';
import { updateUserPreferences } from '@/services/preferencesService';
import { batchCreateCollabBrands, CollabBrand } from '@/services/collabService';
import { batchCreateContentIdeas } from '@/services/contentIdeasService';

/**
 * Migration Utility
 * Migrates localStorage data to Supabase for persistent storage
 */

interface MigrationResult {
  success: boolean;
  migratedCount: number;
  errors: string[];
}

interface FullMigrationResult {
  brandDeals: MigrationResult;
  strategy: MigrationResult;
  goals: MigrationResult;
  planner: MigrationResult;
  production: MigrationResult;
  preferences: MigrationResult;
  collab: MigrationResult;
  contentIdeas: MigrationResult;
  overallSuccess: boolean;
}

// Check if migration has already been completed
export const hasMigrationCompleted = (): boolean => {
  return getString('supabase_migration_completed') === 'true';
};

// Mark migration as completed
export const markMigrationCompleted = (): void => {
  setString('supabase_migration_completed', 'true');
  setString('supabase_migration_date', new Date().toISOString());
};

// =====================================================
// Brand Deals Migration
// =====================================================

export const migrateBrandDeals = async (userId: string): Promise<MigrationResult> => {
  const result: MigrationResult = { success: false, migratedCount: 0, errors: [] };

  try {
    const savedDeals = getString('brandDeals');
    if (!savedDeals) {
      result.success = true;
      return result;
    }

    const deals: BrandDeal[] = JSON.parse(savedDeals);
    if (deals.length === 0) {
      result.success = true;
      return result;
    }

    // Transform deals to remove id and createdAt (will be generated by Supabase)
    const dealsToMigrate = deals.map(deal => {
      const { id, createdAt, ...rest } = deal;
      return rest;
    });

    await batchCreateBrandDeals(userId, dealsToMigrate as Omit<BrandDeal, 'id' | 'createdAt'>[]);
    result.migratedCount = deals.length;
    result.success = true;
  } catch (error) {
    console.error('Error migrating brand deals:', error);
    result.errors.push(`Brand deals: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }

  return result;
};

// =====================================================
// Strategy Migration
// =====================================================

export const migrateStrategy = async (userId: string): Promise<MigrationResult> => {
  const result: MigrationResult = { success: false, migratedCount: 0, errors: [] };

  try {
    const brandValues = getString(StorageKeys.brandValues);
    const missionStatement = getString(StorageKeys.missionStatement);
    const contentValues = getString(StorageKeys.contentValues);
    const visionBoardData = getString(StorageKeys.visionBoardData);
    const strategyNotes = getString('strategyNotes');
    const strategyNoteLinks = getString('strategyNoteLinks');
    const strategyNoteFiles = getString('strategyNoteFiles');

    const updates: Record<string, unknown> = {};

    if (brandValues) {
      try {
        updates.brandValues = JSON.parse(brandValues);
        result.migratedCount++;
      } catch { /* empty */ }
    }

    if (missionStatement) {
      updates.missionStatement = missionStatement;
      result.migratedCount++;
    }

    if (contentValues) {
      updates.contentValues = contentValues;
      result.migratedCount++;
    }

    if (visionBoardData) {
      try {
        updates.visionBoardData = JSON.parse(visionBoardData);
        result.migratedCount++;
      } catch { /* empty */ }
    }

    if (strategyNotes) {
      updates.strategyNotes = strategyNotes;
      result.migratedCount++;
    }

    if (strategyNoteLinks) {
      try {
        updates.strategyNoteLinks = JSON.parse(strategyNoteLinks);
        result.migratedCount++;
      } catch { /* empty */ }
    }

    if (strategyNoteFiles) {
      try {
        updates.strategyNoteFiles = JSON.parse(strategyNoteFiles);
        result.migratedCount++;
      } catch { /* empty */ }
    }

    if (Object.keys(updates).length > 0) {
      await updateUserStrategy(userId, updates as Parameters<typeof updateUserStrategy>[1]);
    }

    result.success = true;
  } catch (error) {
    console.error('Error migrating strategy:', error);
    result.errors.push(`Strategy: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }

  return result;
};

// =====================================================
// Goals Migration
// =====================================================

export const migrateGoals = async (userId: string): Promise<MigrationResult> => {
  const result: MigrationResult = { success: false, migratedCount: 0, errors: [] };

  try {
    const goalsToCreate: Array<{
      goalType: GoalType;
      text: string;
      status?: GoalStatus;
      progressNote?: string;
      year?: number;
      month?: number;
      displayOrder?: number;
    }> = [];

    // Monthly goals
    const monthlyGoalsData = getString(StorageKeys.monthlyGoalsData);
    if (monthlyGoalsData) {
      try {
        const data = JSON.parse(monthlyGoalsData);
        Object.entries(data).forEach(([year, months]) => {
          Object.entries(months as Record<string, unknown[]>).forEach(([monthName, goals]) => {
            const monthIndex = new Date(`${monthName} 1, 2000`).getMonth() + 1;
            (goals as Array<{ text: string; status?: string; progressNote?: string }>).forEach((goal, index) => {
              goalsToCreate.push({
                goalType: 'monthly',
                text: goal.text,
                status: (goal.status as GoalStatus) || 'not-started',
                progressNote: goal.progressNote,
                year: parseInt(year),
                month: monthIndex,
                displayOrder: index,
              });
            });
          });
        });
      } catch { /* empty */ }
    }

    // Short-term goals
    const shortTermGoals = getString(StorageKeys.shortTermGoals);
    if (shortTermGoals) {
      try {
        const goals = JSON.parse(shortTermGoals);
        goals.forEach((goal: { text: string; status?: string; progressNote?: string }, index: number) => {
          goalsToCreate.push({
            goalType: 'short-term',
            text: goal.text,
            status: (goal.status as GoalStatus) || 'not-started',
            progressNote: goal.progressNote,
            displayOrder: index,
          });
        });
      } catch { /* empty */ }
    }

    // Long-term goals
    const longTermGoals = getString(StorageKeys.longTermGoals);
    if (longTermGoals) {
      try {
        const goals = JSON.parse(longTermGoals);
        goals.forEach((goal: { text: string; status?: string; progressNote?: string }, index: number) => {
          goalsToCreate.push({
            goalType: 'long-term',
            text: goal.text,
            status: (goal.status as GoalStatus) || 'not-started',
            progressNote: goal.progressNote,
            displayOrder: index,
          });
        });
      } catch { /* empty */ }
    }

    if (goalsToCreate.length > 0) {
      await batchCreateGoals(userId, goalsToCreate);
      result.migratedCount = goalsToCreate.length;
    }

    result.success = true;
  } catch (error) {
    console.error('Error migrating goals:', error);
    result.errors.push(`Goals: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }

  return result;
};

// =====================================================
// Planner Migration
// =====================================================

export const migratePlanner = async (userId: string): Promise<MigrationResult> => {
  const result: MigrationResult = { success: false, migratedCount: 0, errors: [] };

  try {
    const plannerItems: Omit<PlannerItem, 'id'>[] = [];

    // Planner data
    const plannerData = getString(StorageKeys.plannerData);
    if (plannerData) {
      try {
        const data = JSON.parse(plannerData);
        Object.entries(data).forEach(([date, dayData]) => {
          const day = dayData as { items?: Array<{
            text: string;
            section?: string;
            isCompleted?: boolean;
            startTime?: string;
            endTime?: string;
            description?: string;
            location?: string;
            color?: string;
            order?: number;
            isContentCalendar?: boolean;
            isPlaceholder?: boolean;
          }> };
          if (day.items) {
            day.items.forEach((item, index) => {
              plannerItems.push({
                text: item.text,
                section: (item.section || 'morning') as 'morning' | 'midday' | 'afternoon' | 'evening',
                isCompleted: item.isCompleted || false,
                date,
                startTime: item.startTime,
                endTime: item.endTime,
                description: item.description,
                location: item.location,
                color: item.color,
                displayOrder: item.order || index,
                isContentCalendar: item.isContentCalendar,
                isPlaceholder: item.isPlaceholder,
                isGlobalTask: false,
              });
            });
          }
        });
      } catch { /* empty */ }
    }

    // Global tasks (allTasks)
    const allTasks = getString(StorageKeys.allTasks);
    if (allTasks) {
      try {
        const tasks = JSON.parse(allTasks);
        tasks.forEach((task: { text: string; isCompleted?: boolean }, index: number) => {
          plannerItems.push({
            text: task.text,
            section: 'morning',
            isCompleted: task.isCompleted || false,
            date: '',
            displayOrder: index,
            isGlobalTask: true,
          });
        });
      } catch { /* empty */ }
    }

    if (plannerItems.length > 0) {
      await batchCreatePlannerItems(userId, plannerItems);
      result.migratedCount = plannerItems.length;
    }

    result.success = true;
  } catch (error) {
    console.error('Error migrating planner:', error);
    result.errors.push(`Planner: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }

  return result;
};

// =====================================================
// Production Migration
// =====================================================

export const migrateProduction = async (userId: string): Promise<MigrationResult> => {
  const result: MigrationResult = { success: false, migratedCount: 0, errors: [] };

  try {
    const productionKanban = getString(StorageKeys.productionKanban);
    if (!productionKanban) {
      result.success = true;
      return result;
    }

    const kanbanData = JSON.parse(productionKanban);
    const cardsToCreate: Omit<ProductionCard, 'id'>[] = [];

    // kanbanData is typically an array of columns with cards
    if (Array.isArray(kanbanData)) {
      kanbanData.forEach((column: { id: string; cards?: Array<Record<string, unknown>> }) => {
        if (column.cards) {
          column.cards.forEach((card, index) => {
            cardsToCreate.push({
              columnId: column.id,
              title: (card.title as string) || 'Untitled',
              description: card.description as string | undefined,
              isCompleted: (card.isCompleted as boolean) || false,
              isNew: (card.isNew as boolean) || false,
              addedFrom: card.addedFrom as ProductionCard['addedFrom'],
              platforms: (card.platforms as string[]) || [],
              formats: (card.formats as string[]) || [],
              script: card.script as string | undefined,
              hook: card.hook as string | undefined,
              locationChecked: (card.locationChecked as boolean) || false,
              locationText: card.locationText as string | undefined,
              outfitChecked: (card.outfitChecked as boolean) || false,
              outfitText: card.outfitText as string | undefined,
              propsChecked: (card.propsChecked as boolean) || false,
              propsText: card.propsText as string | undefined,
              filmingNotes: card.filmingNotes as string | undefined,
              status: card.status as ProductionCard['status'],
              isPinned: (card.isPinned as boolean) || false,
              storyboard: card.storyboard as ProductionCard['storyboard'],
              editingChecklist: card.editingChecklist as ProductionCard['editingChecklist'],
              customVideoFormats: (card.customVideoFormats as string[]) || [],
              customPhotoFormats: (card.customPhotoFormats as string[]) || [],
              schedulingStatus: card.schedulingStatus as ProductionCard['schedulingStatus'],
              scheduledDate: card.scheduledDate as string | undefined,
              scheduledStartTime: card.scheduledStartTime as string | undefined,
              scheduledEndTime: card.scheduledEndTime as string | undefined,
              scheduledColor: card.scheduledColor as ProductionCard['scheduledColor'],
              fromCalendar: (card.fromCalendar as boolean) || false,
              plannedDate: card.plannedDate as string | undefined,
              plannedColor: card.plannedColor as ProductionCard['plannedColor'],
              plannedStartTime: card.plannedStartTime as string | undefined,
              plannedEndTime: card.plannedEndTime as string | undefined,
              brainDumpHandledText: card.brainDumpHandledText as string | undefined,
              calendarOnly: (card.calendarOnly as boolean) || false,
              displayOrder: index,
            });
          });
        }
      });
    }

    if (cardsToCreate.length > 0) {
      await batchCreateProductionCards(userId, cardsToCreate);
      result.migratedCount = cardsToCreate.length;
    }

    result.success = true;
  } catch (error) {
    console.error('Error migrating production:', error);
    result.errors.push(`Production: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }

  return result;
};

// =====================================================
// Preferences Migration
// =====================================================

export const migratePreferences = async (userId: string): Promise<MigrationResult> => {
  const result: MigrationResult = { success: false, migratedCount: 0, errors: [] };

  try {
    const updates: Record<string, unknown> = {};

    const selectedTimezone = getString(StorageKeys.selectedTimezone);
    if (selectedTimezone) {
      updates.selectedTimezone = selectedTimezone;
      result.migratedCount++;
    }

    const todayZoomLevel = getString(StorageKeys.todayZoomLevel);
    if (todayZoomLevel) {
      updates.todayZoomLevel = parseFloat(todayZoomLevel);
      result.migratedCount++;
    }

    const weeklyZoomLevel = getString(StorageKeys.weeklyZoomLevel);
    if (weeklyZoomLevel) {
      updates.weeklyZoomLevel = parseFloat(weeklyZoomLevel);
      result.migratedCount++;
    }

    const sidebarState = getString(StorageKeys.sidebarState);
    if (sidebarState) {
      try {
        updates.sidebarState = JSON.parse(sidebarState);
        result.migratedCount++;
      } catch { /* empty */ }
    }

    const sidebarMenuItems = getString(StorageKeys.sidebarMenuItems);
    if (sidebarMenuItems) {
      try {
        updates.sidebarMenuItems = JSON.parse(sidebarMenuItems);
        result.migratedCount++;
      } catch { /* empty */ }
    }

    const contentFormats = getString(StorageKeys.contentFormats);
    if (contentFormats) {
      try {
        updates.contentFormats = JSON.parse(contentFormats);
        result.migratedCount++;
      } catch { /* empty */ }
    }

    const platformUsernames = getString(StorageKeys.platformUsernames);
    if (platformUsernames) {
      try {
        updates.platformUsernames = JSON.parse(platformUsernames);
        result.migratedCount++;
      } catch { /* empty */ }
    }

    const customHooks = getString(StorageKeys.customHooks);
    if (customHooks) {
      try {
        updates.customHooks = JSON.parse(customHooks);
        result.migratedCount++;
      } catch { /* empty */ }
    }

    const hasCompletedOnboarding = getString(StorageKeys.hasCompletedOnboarding);
    if (hasCompletedOnboarding === 'true') {
      updates.hasCompletedOnboarding = true;
      result.migratedCount++;
    }

    const hasSeenGoalsOnboarding = getString(StorageKeys.hasSeenGoalsOnboarding);
    if (hasSeenGoalsOnboarding === 'true') {
      updates.hasSeenGoalsOnboarding = true;
      result.migratedCount++;
    }

    if (Object.keys(updates).length > 0) {
      await updateUserPreferences(userId, updates as Parameters<typeof updateUserPreferences>[1]);
    }

    result.success = true;
  } catch (error) {
    console.error('Error migrating preferences:', error);
    result.errors.push(`Preferences: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }

  return result;
};

// =====================================================
// Collab Migration
// =====================================================

export const migrateCollab = async (userId: string): Promise<MigrationResult> => {
  const result: MigrationResult = { success: false, migratedCount: 0, errors: [] };

  try {
    const collabBrands = getString(StorageKeys.collabBrands);
    if (!collabBrands) {
      result.success = true;
      return result;
    }

    const brands = JSON.parse(collabBrands);
    if (brands.length === 0) {
      result.success = true;
      return result;
    }

    const brandsToCreate: Omit<CollabBrand, 'id'>[] = brands.map((brand: Record<string, string>, index: number) => ({
      brandName: brand.brandName || '',
      contact: brand.contact || '',
      product: brand.product || '',
      status: brand.status || '',
      deliverables: brand.deliverables || '',
      briefContract: brand.briefContract || '',
      rate: brand.rate || '',
      postDate: brand.postDate || '',
      depositPaid: brand.depositPaid || '',
      finalPaymentDueDate: brand.finalPaymentDueDate || '',
      invoiceSent: brand.invoiceSent || '',
      paymentReceived: brand.paymentReceived || '',
      notes: brand.notes || '',
      customData: {},
      displayOrder: index,
    }));

    await batchCreateCollabBrands(userId, brandsToCreate);
    result.migratedCount = brands.length;
    result.success = true;
  } catch (error) {
    console.error('Error migrating collab:', error);
    result.errors.push(`Collab: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }

  return result;
};

// =====================================================
// Content Ideas Migration
// =====================================================

export const migrateContentIdeas = async (userId: string): Promise<MigrationResult> => {
  const result: MigrationResult = { success: false, migratedCount: 0, errors: [] };

  try {
    const ideasToCreate: Array<{
      title: string;
      description?: string;
      source: 'bank-of-ideas' | 'quick-idea' | 'ai-generated' | 'repurposed' | 'other';
      isPinned: boolean;
      isArchived: boolean;
      metadata: Record<string, unknown>;
    }> = [];

    // Bank of ideas
    const bankOfIdeas = getString(StorageKeys.bankOfIdeas);
    if (bankOfIdeas) {
      try {
        const ideas = JSON.parse(bankOfIdeas);
        ideas.forEach((idea: { title?: string; text?: string; description?: string }) => {
          ideasToCreate.push({
            title: idea.title || idea.text || 'Untitled',
            description: idea.description,
            source: 'bank-of-ideas',
            isPinned: false,
            isArchived: false,
            metadata: {},
          });
        });
      } catch { /* empty */ }
    }

    // Content ideas
    const contentIdeas = getString(StorageKeys.contentIdeas);
    if (contentIdeas) {
      try {
        const ideas = JSON.parse(contentIdeas);
        ideas.forEach((idea: { title?: string; text?: string; description?: string; source?: string }) => {
          ideasToCreate.push({
            title: idea.title || idea.text || 'Untitled',
            description: idea.description,
            source: (idea.source as 'bank-of-ideas' | 'quick-idea' | 'ai-generated' | 'repurposed' | 'other') || 'other',
            isPinned: false,
            isArchived: false,
            metadata: {},
          });
        });
      } catch { /* empty */ }
    }

    // Pinned content ideas
    const pinnedContentIdeas = getString(StorageKeys.pinnedContentIdeas);
    if (pinnedContentIdeas) {
      try {
        const ideas = JSON.parse(pinnedContentIdeas);
        ideas.forEach((idea: { title?: string; text?: string; description?: string }) => {
          ideasToCreate.push({
            title: idea.title || idea.text || 'Untitled',
            description: idea.description,
            source: 'other',
            isPinned: true,
            isArchived: false,
            metadata: {},
          });
        });
      } catch { /* empty */ }
    }

    if (ideasToCreate.length > 0) {
      await batchCreateContentIdeas(userId, ideasToCreate);
      result.migratedCount = ideasToCreate.length;
    }

    result.success = true;
  } catch (error) {
    console.error('Error migrating content ideas:', error);
    result.errors.push(`Content ideas: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }

  return result;
};

// =====================================================
// Full Migration
// =====================================================

export const migrateAllDataToSupabase = async (userId: string): Promise<FullMigrationResult> => {
  console.log('Starting full migration to Supabase for user:', userId);

  const results: FullMigrationResult = {
    brandDeals: { success: false, migratedCount: 0, errors: [] },
    strategy: { success: false, migratedCount: 0, errors: [] },
    goals: { success: false, migratedCount: 0, errors: [] },
    planner: { success: false, migratedCount: 0, errors: [] },
    production: { success: false, migratedCount: 0, errors: [] },
    preferences: { success: false, migratedCount: 0, errors: [] },
    collab: { success: false, migratedCount: 0, errors: [] },
    contentIdeas: { success: false, migratedCount: 0, errors: [] },
    overallSuccess: false,
  };

  // Run all migrations
  results.brandDeals = await migrateBrandDeals(userId);
  results.strategy = await migrateStrategy(userId);
  results.goals = await migrateGoals(userId);
  results.planner = await migratePlanner(userId);
  results.production = await migrateProduction(userId);
  results.preferences = await migratePreferences(userId);
  results.collab = await migrateCollab(userId);
  results.contentIdeas = await migrateContentIdeas(userId);

  // Check overall success
  results.overallSuccess = Object.values(results)
    .filter((v): v is MigrationResult => typeof v === 'object' && 'success' in v)
    .every(r => r.success);

  if (results.overallSuccess) {
    markMigrationCompleted();
    console.log('Migration completed successfully!');
  } else {
    console.error('Migration completed with errors:', results);
  }

  return results;
};

// =====================================================
// Clear localStorage after migration (optional)
// =====================================================

export const clearMigratedLocalStorageData = (): void => {
  const keysToKeep = [
    'supabase_migration_completed',
    'supabase_migration_date',
    // Keep auth-related keys
    StorageKeys.user,
    StorageKeys.hasCompletedOnboarding,
  ];

  const allKeys = Object.values(StorageKeys);
  allKeys.forEach(key => {
    if (!keysToKeep.includes(key)) {
      localStorage.removeItem(key);
    }
  });

  // Also remove non-StorageKeys items that were migrated
  localStorage.removeItem('brandDeals');
  localStorage.removeItem('strategyNotes');
  localStorage.removeItem('strategyNoteLinks');
  localStorage.removeItem('strategyNoteFiles');

  console.log('Migrated localStorage data cleared');
};
